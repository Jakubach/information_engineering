#include <iostream>
#include <cmath>
using namespace std;

// Lab 5 - functions - Jakub Chudzi≈Ñski

// Things to understand and achieve:
// One function - one task
// Function name should be clear and logic with it's effect

// 0. https://cppinsights.io/s/8d7ebab5 - Check how compiler see your code
// 0a. https://godbolt.org/z/eTTa559ah - Check instructions for processor generated by your code

// 1. Passing by reference and passing by value
// https://blog.penjee.com/wp-content/uploads/2015/02/pass-by-reference-vs-pass-by-value-animation.gif
// https://blog.penjee.com/passing-by-value-vs-by-reference-java-graphical/

// 2. Inline functions - won't make your old Pentium fly ;)
// Compiler do it itselfs during optimization
/*
 From Bjarne Stroustrup, The C++ Programming Language:
 The inline specifier is a hint to the compiler that it should attempt to generate code for a call of fac() inline rather than laying down the code for the function once and then calling through the usual function call mechanism.
A clever compiler can generate the constant 720 for a call fac(6).
The possibility of mutually recursive inline functions, inline functions that recurse or not depending on input, etc., makes it impossible to guarantee that every call of an inline function is actually inlined.
The degree of cleverness of a compiler cannot be legislated, so one compiler might generate 720, another 6 * fac(5), and yet another an un-inlined call fac(6).
 */
inline int factorial(int n)
{
  if(n<2){
      return 2;
  }
  return n * factorial(n - 1);
  //return (n < 2) ? 1 : n * factorial(n-1);
}

//3. Overloading functions - one function to rule them all
double cos(double x);
float cos(float x);
long double cos(long double x);
// example of implemented function: std::cos(x) - https://en.cppreference.com/w/cpp/numeric/math/cos

//4. Correct the code - self defined function shadows std::pow
// Good practise use only what you need - using std::cout etc.
double pow(float x, float exp){
    float result = 1.0;
    for(int i = 0; i < exp; i++){
        result *= x;
    }
    return result;
}
//5. Dangerous - returning reference to local variable
int& MultiplyBy10(int num){
    int retval = 0; // local variable retval is created
    retval = 10 * num;
    return retval;
} // retval is destroyed, it's not accessible anymore


int main()
{
    cout << "Hello World!" << endl;
    float x = 2;
    float exp = 8;
    // Uncomment and correct the code
    //cout << "2.0^8 = " << pow(x, exp) << endl;
    return 0;
}
